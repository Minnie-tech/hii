1. Implement factorial, fibonnaci, simple application using prolog
1)     Fibonacci
% fib(N, Result) - Result is the Nth Fibonacci number
 
fib(0, 0).
fib(1, 1).
 
fib(N, Result) :-
    N > 1,
    N1 is N - 1,
    N2 is N - 2,
    fib(N1, R1),
    fib(N2, R2),
    Result is R1 + R2.
1)     Factorial
factorial(0, 1).
 
factorial(N, Result) :-
    N > 0,
    N1 is N - 1,
    factorial(N1, R1),
    Result is N * R1.
1)     Simple Arithmetic
sum(A, B, Result) :- Result is A + B.
multiply(A, B, Result) :- Result is A * B.
divide(A, B, Result) :- Result is A / B.
 
% A number is even if remainder after division by 2 is 0
even(N) :- 0 is N mod 2.
 
% A number is odd if remainder after division by 2 is 1
odd(N) :- 1 is N mod 2.


________________






2. Implement IDDFS on given example
dict_gn = {
    'Arad': {'Zerind': 75, 'Timisoara': 118, 'Sibiu': 140},
    'Bucharest': {'Urziceni': 85, 'Giurgiu': 90, 'Pitesti': 101, 'Fagaras': 211},
    'Craiova': {'Drobeta': 120, 'Pitesti': 138, 'Rimnicu': 146},
    'Drobeta': {'Mehadia': 75, 'Craiova': 120},
    'Eforie': {'Hirsova': 86},
    'Fagaras': {'Sibiu': 99, 'Bucharest': 211},
    'Giurgiu': {'Bucharest': 90},
    'Hirsova': {'Eforie': 86, 'Urziceni': 98},
    'Iasi': {'Neamt': 87, 'Vaslui': 92},
    'Lugoj': {'Mehadia': 70, 'Timisoara': 111},
    'Mehadia': {'Lugoj': 70, 'Drobeta': 75},
    'Neamt': {'Iasi': 87},
    'Oradea': {'Zerind': 71, 'Sibiu': 151},
    'Pitesti': {'Rimnicu': 97, 'Bucharest': 101, 'Craiova': 138},
    'Rimnicu': {'Sibiu': 80, 'Pitesti': 97, 'Craiova': 146},
    'Sibiu': {'Rimnicu': 80, 'Fagaras': 99, 'Arad': 140, 'Oradea': 151},
    'Timisoara': {'Lugoj': 111, 'Arad': 118},
    'Urziceni': {'Bucharest': 85, 'Hirsova': 98, 'Vaslui': 142},
    'Vaslui': {'Iasi': 92, 'Urziceni': 142},
    'Zerind': {'Oradea': 71, 'Arad': 75}
}




def dls(start, goal, depth_limit):
    stack = [(start, [start])]
    while stack:
        node, path = stack.pop()
        if node == goal:
            return path
        if len(path) - 1 < depth_limit:
            for neighbor in dict_gn.get(node, {}):
                if neighbor not in path:
                    stack.append((neighbor, path + [neighbor]))
    return None




def IDDFS(start, goal, max_depth):
    for depth in range(max_depth + 1):
        print(f"\nSearching at depth_limit: {depth}")
        path = dls(start, goal, depth)
        if path:
            cost = sum(dict_gn[path[i]][path[i+1]] for i in range(len(path)-1))
            print(f"Path found: {path}")
            print(f"Total cost: {cost}")
            return path, cost
        else:
            print("Path not found")
    return None, None




def main():
    start = "Arad"
    goal = "Bucharest"
    max_depth = 4
    print(f"IDDFS from {start} to {goal}:")
    IDDFS(start, goal, max_depth)


if __name__ == "__main__":
    main()


________________






3. Implement A* on given example 
heuristic = {
    'Arad': 300,
    'Bucharest': 0,
    'Craiova': 245,
    'Drobeta': 464,
    'Eforie': 104,
    'Fagaras': 63,
    'Giurgiu': 455,
    'Hirsova': 109,
    'Iasi': 226,
    'Lugoj': 249,
    'Mehadia': 231,
    'Neamt': 145,
    'Oradea': 346,
    'Pitesti': 100,
    'Rimnicu': 200,
    'Sibiu': 158,
    'Timisoara': 329,
    'Urziceni': 50,
    'Vaslui': 216,
    'Zerind': 45
}


dict_gn = {
    'Arad': {'Zerind': 75, 'Timisoara': 118, 'Sibiu': 140},
    'Bucharest': {'Urziceni': 85, 'Giurgiu': 90, 'Pitesti': 101, 'Fagaras': 211},
    'Craiova': {'Drobeta': 120, 'Pitesti': 138, 'Rimnicu': 146},
    'Drobeta': {'Mehadia': 75, 'Craiova': 120},
    'Eforie': {'Hirsova': 86},
    'Fagaras': {'Sibiu': 99, 'Bucharest': 211},
    'Giurgiu': {'Bucharest': 90},
    'Hirsova': {'Eforie': 86, 'Urziceni': 98},
    'Iasi': {'Neamt': 87, 'Vaslui': 92},
    'Lugoj': {'Mehadia': 70, 'Timisoara': 111},
    'Mehadia': {'Lugoj': 70, 'Drobeta': 75},
    'Neamt': {'Iasi': 87},
    'Oradea': {'Zerind': 71, 'Sibiu': 151},
    'Pitesti': {'Rimnicu': 97, 'Bucharest': 101, 'Craiova': 138},
    'Rimnicu': {'Sibiu': 80, 'Pitesti': 97, 'Craiova': 146},
    'Sibiu': {'Rimnicu': 80, 'Fagaras': 99, 'Arad': 140, 'Oradea': 151},
    'Timisoara': {'Lugoj': 111, 'Arad': 118},
    'Urziceni': {'Bucharest': 85, 'Hirsova': 98, 'Vaslui': 142},
    'Vaslui': {'Iasi': 92, 'Urziceni': 142},
    'Zerind': {'Oradea': 71, 'Arad': 75}
}




import heapq


def a_star(start, goal):
    open_set = []
    heapq.heappush(open_set, (0 + heuristic[start], 0, start, [start])) 
    closed_set = set()


    while open_set:
        f, g, current, path = heapq.heappop(open_set)


        if current == goal:
            return path, g  


        if current in closed_set:
            continue


        closed_set.add(current)


        for neighbor, cost in dict_gn.get(current, {}).items():
            if neighbor in closed_set:
                continue
            g_new = g + cost
            f_new = g_new + heuristic[neighbor]
            heapq.heappush(open_set, (f_new, g_new, neighbor, path + [neighbor]))


    return None, None


def main():
    start = "Arad"
    goal = "Bucharest"
    max_depth = 4




    print("\nA* search from Arad to Bucharest:")
    path, cost = a_star(start, goal)
    if path:
        print(f"Path found: {path}")
        print(f"Total cost: {cost}")
    else:
        print("No path found")


if __name__ == "__main__":
    main()


________________




 
4. Implement adversarial search using min-max algorithm.
class MinimaxTree:
    def __init__(self):
        self.tree = {}
        self.leaf_values = {}


    def add_node(self, parent, children):
        self.tree[parent] = children


    def minimax(self, node, is_max_turn):
        if node not in self.tree:  # leaf node
            return self.leaf_values[node], [node]


        best_val = float('-inf') if is_max_turn else float('inf')
        best_path = []


        for child in self.tree[node]:
            val, path = self.minimax(child, not is_max_turn)
            if (is_max_turn and val > best_val) or (not is_max_turn and val < best_val):
                best_val = val
                best_path = [node] + path


        return best_val, best_path


# Create tree matching output path A -> C -> F -> 2
tree = MinimaxTree()


tree.add_node('A', ['B', 'C'])
tree.add_node('B', ['D', 'E'])
tree.add_node('C', ['F'])
tree.add_node('D', ['3', '5'])
tree.add_node('E', ['0', '-1'])
tree.add_node('F', ['2', '1'])


tree.leaf_values = {'3': 3, '5': 5, '0': 0, '-1': -1, '2': 2, '1': 1}


val, path = tree.minimax('A', True)


print("root node :", val)
print("optimal path :", " -> ".join(path))


________________


 


5. Prove the goal sentence from the following set of statements in FOPL by applying forward, backward and resolution inference algorithms. 
# english  
eng_statements = [ 
    "The passport is approved if all documents are submitted.", 
    "All documents are submitted if all documents are correct.", 
    "If the applicant has any criminal record, the passport is not approved.", 
    "All documents are correct.", 
    "Goal: Is the passport approved?" 
] 
 
for s in eng_statements: 
    print(s) 
print() 
 
# FOL  
print("FOL Statements:") 
fol_statements = [ 
    "∀x (Submitted(x) → Approved(x))", 
    "∀x (Correct(x) → Submitted(x))", 
    "∀x (CriminalRecord(x) → ¬Approved(x))", 
    "Correct(Manaswi)", 
    "Goal: Approved(Manaswi)?" 
] 
for s in fol_statements: 
    print(s) 
print() 
 
# forward chaining  
facts = {"Correct_Manaswi"} 
rules = [ 
    (["Submitted_Manaswi"], "Approved_Manaswi"), 
    (["Correct_Manaswi"], "Submitted_Manaswi"), 
    (["CriminalRecord_Manaswi"], "NotApproved_Manaswi") 
] 
goal = "Approved_Manaswi" 
 
print("Forward chaining:") 
inferred = set() 
while True: 
    new_inferred = False 
    for premises, conclusion in rules: 
        if all(p in facts for p in premises) and conclusion not in facts: 
            print(f"Inferred: {conclusion} from {premises}") 
            inferred.add(conclusion) 
            new_inferred = True 
    if not new_inferred: 
        break 
    facts.update(inferred) 
print(f"Facts after forward chaining: {facts}\n") 
 
# backward chaining  
def backward_chain(goal, facts, rules, visited=None): 
    if visited is None: 
        visited = set() 
    if goal in facts: 
        print(f"Goal {goal} found in facts.") 
        return True 
    if goal in visited: 
        return False 
    visited.add(goal) 
    for premises, conclusion in rules: 
        if conclusion == goal: 
            print(f"To prove {goal}, need to prove {premises}") 
            if all(backward_chain(p, facts, rules, visited) for p in premises): 
                print(f"All premises {premises} proven for goal {goal}.") 
                return True 
    print(f"Failed to prove {goal}.") 
    return False 
 
print("Backward chaining:") 
bc_result = backward_chain(goal, {"Correct_Manaswi"}, rules) 
print(f"Backward chaining result: {'Goal proven' if bc_result else 'Goal not proven'}\n") 
 
# resolution  
def negate(literal): 
    return literal[3:] if literal.startswith("Not") else "Not" + literal 
 
def resolve(ci, cj): 
    resolvents = [] 
    for di in ci: 
        for dj in cj: 
            if di == negate(dj): 
                new_clause = (ci - {di}) | (cj - {dj}) 
                resolvents.append(new_clause) 
    return resolvents 
 
def resolution(clauses, goal): 
    clauses = clauses.copy() 
    clauses.append({negate(goal)}) 
    print("Initial clauses:") 
    for c in clauses: 
        print(c) 
    new = set() 
    while True: 
        pairs = [(clauses[i], clauses[j]) for i in range(len(clauses)) for j in range(i+1, len(clauses))] 
        for (ci, cj) in pairs: 
            res_clauses = resolve(ci, cj) 
            for res_c in res_clauses: 
                if not res_c: 
                    print("Derived empty clause -> contradiction found, goal proved!") 
                    return True 
                new.add(frozenset(res_c)) 
        new = set(new) 
        clauses_set = set(frozenset(c) for c in clauses) 
        if new.issubset(clauses_set): 
            print("No new clauses generated, cannot prove goal by resolution.") 
            return False 
        for c in new: 
            if c not in clauses_set: 
                clauses.append(set(c)) 
 
print("Resolution:") 
clauses = [ 
    {"NotSubmitted_Manaswi", "Approved_Manaswi"}, 
    {"NotCorrect_Manaswi", "Submitted_Manaswi"}, 
    {"NotCriminalRecord_Manaswi", "NotApproved_Manaswi"}, 
    {"Correct_Manaswi"} 
] 
 
res_result = resolution(clauses, goal) 
print(f"Resolution result: {'Goal proven' if res_result else 'Goal not proven'}")
________________








6. Design a prototype of an expert system
# Simple Expert System for Disease 
Diagnosis 
 
# Knowledge Base (rules) 
rules = [ 
    {"conditions": ["fever", "cough"], 
"conclusion": "flu"}, 
    {"conditions": ["fever", "rash"], 
"conclusion": "measles"}, 
    {"conditions": ["headache", "nausea"], 
"conclusion": "migraine"} 
] 
 
# Inference Engine (forward chaining) def diagnose(symptoms):     for rule in rules: 
        if all(symptom in symptoms for symptom in rule["conditions"]): 
            return f"Based on symptoms, you may have: {rule['conclusion']}"     return "No matching disease found." 
 
# User input if __name__ == "__main__": 
    user_symptoms = input("Enter your symptoms separated by comma: 
").lower().split(",") 
    user_symptoms = [s.strip() for s in user_symptoms]     print(diagnose(user_symptoms)) 


________________






7. Implement a planning agent for a given example.


def flight_scheduling(requests, start_airport="A"): 
    current_airport = start_airport 
    planned_steps = [] 
    step_num = 1 
     
    pending_requests = requests.copy() 
     
    while pending_requests: 
        next_request = min(pending_requests, key=lambda x: abs(ord(x[0]) - ord(current_airport))) 
        pending_requests.remove(next_request) 
         
        departure, arrival = next_request 
         
        if current_airport != departure: 
            planned_steps.append(f"{step_num}. Move from airport {current_airport} to departure airport 
{departure}") 
            step_num += 1 
         
        current_airport = departure 
         
        planned_steps.append(f"{step_num}. We schedule flight from {departure} to {arrival}") 
        step_num += 1 
         
        if current_airport != arrival: 
            planned_steps.append(f"{step_num}. Move from airport {current_airport} to arrival airport {arrival}") 
 
 
            
 
 
 step_num += 1 
         
        current_airport = arrival 
         
        planned_steps.append(f"{step_num}. Flight departed from {departure} and arrived at {arrival}") 
        step_num += 1 
     
    print("Planned steps:") 
    for step in planned_steps: 
        print(step) 
     
    print("\nGenerated output:") 
    print(f"Total flights scheduled: {len(requests)}") 
    print(f"Final airport after all flights: {current_airport}") 
 
 
requests = [("C", "F"), ("A", "D"), ("B", "E")] 
flight_scheduling(requests)